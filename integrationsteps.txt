================================================================================
       BLACKBOOK L1 â†” L2 INTEGRATION IMPLEMENTATION PLAN
================================================================================

Created: December 7, 2025
Status: Planning Phase
L2 Server: Port 1234 (this codebase)
L1 Server: Port 8080 (Railway/external)

================================================================================
                         CURRENT STATE ANALYSIS
================================================================================

âœ… WHAT ALREADY EXISTS (L2):
   â€¢ godmode.rs - Ed25519 signing/verification with deterministic test accounts
   â€¢ SignedMessage struct - Basic signed message envelope
   â€¢ Test accounts (ALICE, BOB, etc.) with L1_<pubkey> addresses
   â€¢ Prediction markets with betting (no signature verification)
   â€¢ CPMM engine for market pricing
   â€¢ 10 godmode tests passing

âŒ WHAT'S MISSING (Gap from integration doc):
   â€¢ src/l1_rpc_client.rs - HTTP client to call L1 blockchain
   â€¢ src/signed_transaction.rs - Full transaction envelope with types
   â€¢ src/bridge.rs - Cross-layer token bridge logic
   â€¢ /rpc/* endpoints - L1 verification endpoints
   â€¢ /bridge/* endpoints - Token bridging endpoints
   â€¢ L1_RPC_URL environment variable support
   â€¢ Signature-verified bet placement
   â€¢ Settlement recording to L1

âš ï¸  ADDRESS FORMAT MISMATCH:
   â€¢ Current code uses: L1_<HEX_PUBKEY>
   â€¢ Integration doc specifies: bb1_ (L1) and bb2_ (L2)
   â€¢ Decision needed: Change format or support both?

================================================================================
                         PHASE 1: L1 RPC CLIENT
================================================================================

Priority: ğŸ”´ HIGH (Foundation for all cross-layer communication)
Estimated time: 1.5 hours
Dependencies: None

STEP 1.1: Create src/l1_rpc_client.rs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Create L1RpcClient struct:
  - endpoint_url: String (from L1_RPC_URL env var)
  - timeout: Duration (default 30 seconds)
  - mock_mode: bool (true when L1_RPC_URL not set)

â–¡ Implement core methods:
  - new() -> Self
  - new_from_env() -> Self (reads L1_RPC_URL)
  - is_connected() -> bool

STEP 1.2: Implement verify_signature()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Method signature:
  pub async fn verify_signature(
      &self,
      pubkey: &str,
      message: &[u8],
      signature: &str
  ) -> Result<bool, L1RpcError>

â–¡ In mock mode: Use local Ed25519 verification (godmode)
â–¡ In live mode: POST to L1's /rpc/verify-l1-signature

STEP 1.3: Implement get_balance()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Method signature:
  pub async fn get_balance(&self, address: &str) -> Result<f64, L1RpcError>

â–¡ In mock mode: Return local ledger balance
â–¡ In live mode: GET L1's /rpc/account/{address}

STEP 1.4: Implement get_nonce()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Method signature:
  pub async fn get_nonce(&self, address: &str) -> Result<u64, L1RpcError>

â–¡ In mock mode: Return 0 (or track locally)
â–¡ In live mode: GET L1's /rpc/nonce/{address}

STEP 1.5: Add to lib.rs and main.rs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Add pub mod l1_rpc_client to lib.rs
â–¡ Add mod l1_rpc_client to main.rs
â–¡ Export L1RpcClient in lib.rs

STEP 1.6: Add environment variable support
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Read L1_RPC_URL from environment
â–¡ Log connection status on startup:
  - "ğŸ”— L1 RPC: Connected to {url}"
  - "âš ï¸  L1 RPC: Mock mode (L1_RPC_URL not set)"

STEP 1.7: Write tests
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ test_mock_mode_verification()
â–¡ test_mock_mode_balance()
â–¡ test_rpc_client_creation()

================================================================================
                    PHASE 2: SIGNED TRANSACTION SUPPORT
================================================================================

Priority: ğŸ”´ HIGH (Required for secure transactions)
Estimated time: 1 hour
Dependencies: Phase 1 (for verification)

STEP 2.1: Create src/signed_transaction.rs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Create SignedTxType enum:
  - Transfer = 0
  - Bridge = 4
  - BetPlacement = 7
  - BetResolution = 8
  - MarketLaunch = 9
  - AddLiquidity = 10
  - RemoveLiquidity = 11

â–¡ Create TransactionPayload enum:
  - Transfer { to: String, amount: f64 }
  - Bridge { target_layer: String, target_address: String, amount: f64 }
  - BetPlacement { market_id: String, outcome: usize, amount: f64 }
  - BetResolution { market_id: String, winning_outcome: usize }
  - MarketLaunch { event_id: String, liquidity: f64 }

STEP 2.2: Create SignedTransaction struct
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Fields:
  - sender_pubkey: String (64 hex chars)
  - sender_address: String (L1_... format)
  - nonce: u64
  - timestamp: u64
  - tx_type: SignedTxType
  - payload: TransactionPayload
  - signature: String (128 hex chars)

â–¡ Methods:
  - new() - Create and sign transaction
  - verify() - Verify signature locally
  - verify_with_l1() - Verify via L1 RPC
  - is_expired() - Check timestamp (5 minute window)
  - to_signing_bytes() - Canonical bytes for signing

STEP 2.3: Add to lib.rs and main.rs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Add pub mod signed_transaction to lib.rs
â–¡ Add mod signed_transaction to main.rs
â–¡ Export SignedTransaction, SignedTxType, TransactionPayload

STEP 2.4: Write tests
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ test_create_and_verify_transaction()
â–¡ test_transaction_expiry()
â–¡ test_different_tx_types()
â–¡ test_invalid_signature_rejected()

================================================================================
                     PHASE 3: BRIDGE ENDPOINTS
================================================================================

Priority: ğŸŸ¡ MEDIUM (Required for L1â†”L2 token movement)
Estimated time: 1.5 hours
Dependencies: Phase 1, Phase 2

STEP 3.1: Create src/bridge.rs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Create BridgeStatus enum:
  - Pending
  - Confirmed
  - Completed
  - Failed

â–¡ Create PendingBridge struct:
  - bridge_id: String
  - from_layer: String
  - to_layer: String
  - from_address: String
  - to_address: String
  - amount: f64
  - status: BridgeStatus
  - created_at: u64
  - completed_at: Option<u64>
  - l1_tx_hash: Option<String>

â–¡ Create BridgeManager struct:
  - pending_bridges: HashMap<String, PendingBridge>
  - Methods: initiate(), complete(), get_status(), list_pending()

STEP 3.2: Add POST /bridge/complete endpoint
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ L1 calls this when bridge L1â†’L2 is confirmed
â–¡ Request body:
  {
    "bridge_id": "...",
    "from_address": "bb1_...",
    "to_address": "bb2_...",
    "amount": 100.0,
    "l1_tx_hash": "...",
    "l1_slot": 12345
  }
â–¡ Handler:
  - Validate bridge_id exists in pending
  - Mint tokens to to_address on L2 ledger
  - Mark bridge as Completed
  - Return { success: true, l2_balance: new_balance }

STEP 3.3: Add POST /rpc/bridge endpoint
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ User initiates bridge L2â†’L1
â–¡ Request body: SignedTransaction with Bridge payload
â–¡ Handler:
  - Verify signature
  - Check L2 balance >= amount
  - Lock tokens on L2 (deduct from balance)
  - Create PendingBridge record
  - Forward to L1 (or queue for L1 processing)
  - Return { bridge_id, status: "pending" }

STEP 3.4: Add GET /rpc/bridge/:id endpoint
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Check status of a bridge
â–¡ Return PendingBridge details

STEP 3.5: Add to AppState
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Add bridge_manager: BridgeManager to AppState
â–¡ Initialize on startup

STEP 3.6: Add to lib.rs and main.rs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Add pub mod bridge to lib.rs
â–¡ Add mod bridge to main.rs
â–¡ Export BridgeManager, PendingBridge, BridgeStatus

================================================================================
                    PHASE 4: SIGNATURE-VERIFIED BETS
================================================================================

Priority: ğŸŸ¡ MEDIUM (Secure bet placement)
Estimated time: 1 hour
Dependencies: Phase 1, Phase 2

STEP 4.1: Create POST /bet/signed endpoint
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Accept SignedTransaction with BetPlacement payload
â–¡ Handler:
  - Verify signature locally (or via L1 if configured)
  - Verify nonce (prevent replay)
  - Check timestamp not expired
  - Extract market_id, outcome, amount from payload
  - Process bet using existing logic
  - Return bet_id and confirmation

STEP 4.2: Add nonce tracking to AppState
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Add nonces: HashMap<String, u64> to AppState
â–¡ On each signed transaction:
  - Check nonce > stored nonce
  - Update stored nonce after success

STEP 4.3: Update existing /bet endpoint
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Keep existing endpoint for backwards compatibility
â–¡ Add optional "signature" field to BetRequest
â–¡ If signature provided, verify before processing

STEP 4.4: Add POST /rpc/verify endpoint (local)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Verify signatures locally (for testing/L2-only mode)
â–¡ Request: { pubkey, message, signature }
â–¡ Response: { valid: bool, error?: string }

================================================================================
                    PHASE 5: SETTLEMENT RECORDING
================================================================================

Priority: ğŸŸ¢ LOWER (Audit trail on L1)
Estimated time: 45 minutes
Dependencies: Phase 1

STEP 5.1: Update market resolution flow
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ After resolving a market on L2:
  - Call L1's POST /rpc/settlement
  - Record L1 tx_hash in market metadata
  - Log settlement confirmation

STEP 5.2: Create settlement recording function
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ In l1_rpc_client.rs:
  pub async fn record_settlement(
      &self,
      market_id: &str,
      outcome: usize,
      winners: Vec<(String, f64)>  // (address, payout)
  ) -> Result<SettlementResponse, L1RpcError>

â–¡ In mock mode: Just log and return success
â–¡ In live mode: POST to L1's /rpc/settlement

STEP 5.3: Modify resolve endpoint
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ After successful resolution:
  - Call record_settlement()
  - Include L1 tx_hash in response

================================================================================
                         IMPLEMENTATION ORDER
================================================================================

Day 1: Foundation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ 1.1-1.7: Create l1_rpc_client.rs with mock mode
â–¡ 2.1-2.4: Create signed_transaction.rs

Day 2: Bridge & Integration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ 3.1-3.6: Create bridge.rs and endpoints
â–¡ 4.1-4.4: Add signature-verified bet placement

Day 3: Polish & Testing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ 5.1-5.3: Add settlement recording
â–¡ Integration tests
â–¡ Update layer2integration.md with actual status

================================================================================
                         ENVIRONMENT VARIABLES
================================================================================

Required for L1 connection:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
L1_RPC_URL=https://your-l1-node.railway.app    # L1 blockchain URL
JWT_SECRET=your_256_bit_secret                  # Shared auth secret

Optional configuration:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PORT=1234                    # L2 server port (default: 1234)
GODMODE_ENABLED=true         # Enable test accounts (default: true)
L1_VERIFY_BETS=false         # Require L1 verification for bets (default: false)
BRIDGE_TIMEOUT_SECS=300      # Bridge confirmation timeout (default: 300)

================================================================================
                         SUCCESS CRITERIA
================================================================================

Phase 1 Complete When:
â–¡ L1RpcClient can be created with/without L1_RPC_URL
â–¡ Mock mode verification works with godmode accounts
â–¡ All tests pass

Phase 2 Complete When:
â–¡ SignedTransaction can be created and verified
â–¡ All transaction types serialize/deserialize correctly
â–¡ Expiry checking works

Phase 3 Complete When:
â–¡ /bridge/complete endpoint works
â–¡ /rpc/bridge endpoint creates pending bridges
â–¡ Bridge status can be queried

Phase 4 Complete When:
â–¡ /bet/signed endpoint accepts signed transactions
â–¡ Nonce replay protection works
â–¡ Invalid signatures are rejected

Phase 5 Complete When:
â–¡ Market resolution records to L1 (or logs in mock mode)
â–¡ Settlement confirmation is stored

================================================================================
                              NOTES
================================================================================

â€¢ All phases can be tested with mock mode (no real L1 required)
â€¢ Address format decision pending: L1_/L2_ vs bb1_/bb2_
â€¢ Existing endpoints remain backwards compatible
â€¢ L1 verification is optional initially (L1_VERIFY_BETS=false)

================================================================================
